JSDoc: Global Global Members (constant) useLawyerUser useLawyerUser listens for changes in the lawyer's session and fetches the lawyer from supabase Source: useUser.js, line 172 (constant) useSession useSession listens for changes in the user's session Source: useUser.js, line 60 (constant) useStripePolice useStripePolice creates a stripe user if it doesn't exist and checks if the stripeCustomerId is real Source: useUser.js, line 95 Methods useKeystrokeStateIndex(slides) &rarr; {Array} A custom React hook that manages the state index based on keystrokes. Parameters: Name Type Description slides number The total number of slides or states. Source: useKeystrokeStateIndex.js, line 9 Returns: An array containing the current state index and a function to update it. Type Array Example const [stateIndex, setStateIndex] = useKeystrokeStateIndex(5); useRedirectIfSignedIn() useRedirectIfSignedIn redirects to /app if user is signed in, to be used in login page contexts Source: useUser.js, line 243 useRedirectLawyerIfSignedIn() useRedirectLawyerIfSignedIn redirects to /lawyers if user is signed in, to be used in login page contexts Source: useUser.js, line 264 useUser() useUser listens for changes in the user's session and fetches the user from the database Source: useUser.js, line 11 Returns: user object from database 

// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id           String   @id @default(uuid())
  email        String   @unique
  phone        String?  @unique
  first        String?
  last         String?
  address      String?
  city         String?
  state        String?
  zip          String?
  imageUrl    String?
  cases        Case[]
  savedLawyers Lawyer[]

}

model Lawyer {
  id          String    @id @default(uuid()) // todo: right now, linked to authId, but this means we can't add lawyers that aren't members
  email       String    @unique
  phone       String?   @unique
  first       String?
  last        String?
  description String?
  firm        String?
  imageUrl    String?
  savedBy     User[]
  services    Service[]
  inquiries   Inquiry[]

  address      String?
  city         String?
  state        String?
  zip          String?

  // membership info
  barMemberships BarMembership[]

  // stripe info
  stripeCustomerId String?

  // plaid verification
  plaidVerificationId String?
  plaidVerified Boolean @default(false)
  lastVerifiedAt DateTime?

  agreements Agreement[]

  verification LawyerVerificationRequest[]
  invitations  Invitation[]
}

model BarMembership {
  id        String   @id @default(uuid())
  barNumber String   @unique
  state     String
  lawyer    Lawyer   @relation(fields: [lawyerId], references: [id])
  lawyerId  String

  // verification
  verified  Boolean @default(false)
  verifiedAt DateTime?
  verifiedBy String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Service {
  id        String      @id @default(uuid())
  invitationId String?
  invitation Invitation? @relation(fields: [invitationId], references: [id])
  type      ServiceType
  lawyer    Lawyer      @relation(fields: [lawyerId], references: [id])
  lawyerId  String
  price     Int
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt

  @@unique([invitationId, type])
}

enum ServiceType {
  quick
  advisory
  attorney
  review
}

model LawyerVerificationRequest {
  id           String   @id @default(uuid())
  barNumber    String
  jurisdiction String
  lawyer       Lawyer   @relation(fields: [lawyerId], references: [id])
  lawyerId     String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

model Case {
  // state
  id        String   @id @default(uuid())
  user      User     @relation(fields: [userId], references: [id])
  userId    String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // user input
  title       String
  whatsUp   String?
  goals     String?
  dates     String?
  documents Document[]

  // review
  review             String?
  questions          Question[]
  // Analysis
  analysisId String?
  analysis CaseAnalysis?


  // ai assistance for user
  summary String? // summary to help user understand their case
  description String?
  interview   String?

  // case info review
  status             String?
  interviewDueBy    DateTime?
  readyForInvitation Boolean @default(false)
  invitationsSent    Boolean @default(false)

  // invitations
  recommendedServiceIds String[]     @db.VarChar(255) // Array of Service IDs
  invitations           Invitation[]

  // agreements
  agreements Agreement[]
}

model CaseAnalysis {
  id        String   @id @default(uuid())
  case      Case     @relation(fields: [caseId], references: [id])
  caseId    String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // analysis fields
  freeOptions String?
  oddsOfSuccess String?
  strategy String?
  costEstimate String?
}

model Question {
  id        String   @id @default(uuid())
  question  String   @unique
  subQuestion String
  answer    String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  case     Case     @relation(fields: [caseId], references: [id])
  caseId   String
}

model Document {
  id        String   @id @default(uuid())
  caseId    String
  case      Case     @relation(fields: [caseId], references: [id])
  userId    String // Assuming you want to directly link documents to users as well
  fileName  String
  fileType  String
  url       String // URL to the document in Supabase Storage
  createdAt DateTime @default(now())
}

////////////////////////

model Invitation {
  id String @id @default(uuid())

  // on creation
  case     Case      @relation(fields: [caseId], references: [id])
  caseId   String
  lawyers  Lawyer    @relation(fields: [lawyerId], references: [id])
  lawyerId String
  comment  String
  dueBy    DateTime?

  // set by lawyer
  status        String?
  lawyerComment String?
  services      Service[]

  // handler by us
  ourAnalysis String?
  strategyReview String?

  // set by user
  usersFeedback String?
  rejected     Boolean @default(false)
  favorite     Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([caseId, lawyerId])
}

model Inquiry {
  id        String   @id @default(uuid())
  question  String   @unique
  answer    String?
  lawyerId  String
  lawyer    Lawyer   @relation(fields: [lawyerId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Interview {
  id           String   @id @default(uuid())
  invitationId String   @unique
  questions    String[]
  answers      String[]
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}


// represents the agreement between the user and the lawyer
model Agreement {
  id        String   @id @default(uuid())
  case      Case     @relation(fields: [caseId], references: [id])
  caseId    String
  lawyer    Lawyer   @relation(fields: [lawyerId], references: [id])
  lawyerId  String
  invitationId String?

  contractUrl String
  contractHash String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

////////////////////////


// model CaseUpdate {
//   id 
// }

## Style Guide

We use a minimalistic style guide to keep our development simple and consistent. Our main design value is to keep things ruthlessly functinoal. Every button, piece of text, character, color, and image is chiseled away unless it serves a necessary function to help solve users problems. We think of the purpose of design as removing confusion via negativa. Every click saved is a win. When you're developing, please refer to these principles.

We use Tailwind CSS for styling. Here are some common classes we use to help your development. Please feel free to get hyper-creative, this is meant just as a reference to where we're at now.

### Typography

```tailwindcss
@layer base {
  .h1 {
    @apply text-5xl font-bold leading-tight tracking-tighter;
  }
  .h2 {
    @apply text-4xl font-bold leading-snug tracking-tight;
  }
  .h3 {
    @apply text-3xl font-bold leading-snug tracking-tight;
  }
  .h4 {
    @apply text-2xl font-bold leading-normal tracking-normal;
  }
  .h5 {
    @apply text-xl font-bold leading-normal tracking-normal;
  }
  .h6 {
    @apply text-lg font-bold leading-relaxed tracking-normal;
  }
  .p {
    @apply text-base leading-relaxed tracking-wide;
  }
  .p-sm {
    @apply text-sm leading-relaxed tracking-wide;
  }
}
```


## Financials

Right now, we're thinking mostly about scale as opposed to unit economics, with unit economics simply about providing sustainable value to customers such that we can reach scale.

The initial thinking is something like "charge lawyers low flat rate per match", and "charge customers as little as possible for services". Ideally we'd like to not even charge the customer, but we want to provide them strong pricing guarantees. @AI how could we structure the contract without


JSDoc: Home Home ImpossibleLaw ImpossibleLaw is a marketplace for legal services. We connect clients with legal services, offering a new way to shop for legal services. Specifically, we are attempting to remove the uncertainty and insider knowledge required to navigate legal matters skillfully, and have assurance that one is getting good value. In doing so, we are attempting to make shopping for legal services more like the typical online shopping experience consumers are accustomed to. From the business angle, we are like a Costco for lawyers, providing them insane value for their membership, and a steady stream of clients. We also remove the tediousness of online platforms and their rating systems, where client star reviews and comments can be unfair to lawyers. Instead, we align our incentives with lawyers by charging for matches, not leads. We charge a flat fee for each match. The magic of our business is that leads can flow in from multiple sources, meaning we can spin up multiple brands and experiments to bring in leads. This means we can go after different markets with different brands. We can also go after consumers, businesses, and even general counsels differently. We can experiment at low cost under one specific brand. We can even partner with other platforms to bring in leads. This also allow us to better incentivize managers based on their platform alone. ImpossibleLaw Platform v1 Product Offering We offer a few legal products to start. Our priority is to provide customers with strong pricing clarity and strong guarantees, so they know exactly what they're getting. Shotgun Strategy The shotgun strategy package allows users to get multiple written or video opinions on a matter in a 48 hour turnaround. This is meant for clients who are looking to assess their situation quickly and get a sense of their options. This is a great way to get a sense of the legal landscape and the potential costs of a case. This is also meant as a better way for lawyers to attract clients, since they actually get some revenue and know that their client serious enough to pay for an initial consult. Application Details This repository is our initial matchmaking platform, built using Tailwind CSS and Next.js, and deployed in Vercel. We use Supabase for user and lawyer authentication (two different auth services), as well as for database storage. We use Stripe for payment processing. We use Mailgun for email services. We use Plaid to identify lawyers. Services Prisma Schema You can find our prisma database schema above. Note, even with the below Prisma schema, we still use Supabase sdk not prisma so we can run in the client. Here is an example: const { data: user, error } = await supabase .from('User') .select('*') .eq('id', userId) .single() const cases = user.Case // for some reason it is capitalized Other Codebase Considerations Our app has a /app/... and /lawyers/... routing that is handled by Next.js. We use the /app/... routing for the user side of the app, and the /lawyers/... routing for the lawyer side of the app. Each has a different authentication service, and different views. We use the same database for both. Prompt Use the above to fulfill the following request, and remember to develop using the services and architecture above: 

Rank the top 3 big picture priorities.  Rank the top three sirens / antipriorities / traps.  Then translate those into a list of the top action items to address in this next sprint.